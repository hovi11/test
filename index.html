<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tes Clicker</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* Ваши стили остаются без изменений */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --button-color: #007bff;
            --panel-color: #f0f0f0;
            --combo-color: #ff5722;
        }

        body.dark {
            --bg-color: #1e1e1e;
            --text-color: #ffffff;
            --button-color: #1a73e8;
            --panel-color: #2d2d2d;
            --combo-color: #ff7043;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
            margin: 0;
            padding: 10px;
            transition: all 0.3s;
            user-select: none;
        }

        #click-area {
            width: 150px;
            height: 150px;
            margin: 20px auto;
            background-image: url('https://q-xx.bstatic.com/xdata/images/hotel/max500/215500382.jpg?k=bfab20a750261abbb7ea08a9886b1eb9e0a7795acd9a3aefca9830a56cccf26b&s=100x100');
            background-size: cover;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid var(--button-color);
            position: relative;
        }

        .stats {
            margin: 10px 0;
            font-size: 18px;
        }

        .nav {
            display: flex;
            justify-content: space-around;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-color);
            padding: 10px;
        }

        .nav-button {
            padding: 10px 15px;
            background-color: var(--button-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .menu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 400px;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
        }

        .upgrade {
            margin: 10px 0;
            padding: 10px;
            background-color: var(--bg-color);
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #ddd;
        }

        .upgrade.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .close-button {
            position: absolute;
            top: 5px;
            right: 10px;
            cursor: pointer;
            font-size: 20px;
        }

        .combo-display {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--combo-color);
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-bar {
            height: 5px;
            background: linear-gradient(to right, #4CAF50, #FFC107, #F44336);
            margin-top: 5px;
            border-radius: 3px;
            display: none;
        }

        .critical-hit {
            animation: criticalAnimation 0.5s;
        }

        @keyframes criticalAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="stats">
        <div>Баланс: <span id="balance">0</span></div>
        <div>Урон за клик: <span id="damage-per-click">1</span></div>
        <div>Уровень: <span id="level">1</span> (<span id="current-damage">0</span>/<span id="required-damage">500</span>)</div>
        <div>Всего нанесено урона: <span id="total-damage">0</span></div>
    </div>

    <div id="click-area" onclick="clickDamage()">
        <div class="combo-display" id="combo-display">x1.0</div>
        <div class="combo-bar" id="combo-bar"></div>
    </div>

    <div class="nav">
        <button class="nav-button" onclick="openMenu('shop-menu')">Магазин</button>
        <button class="nav-button" onclick="openMenu('leaderboard-menu')">Таблица лидеров</button>
        <button class="nav-button" onclick="openMenu('boost-menu')">Усиления</button>
        <button class="nav-button" onclick="openMenu('achievements-menu')">Достижения</button>
    </div>

    <div id="shop-menu" class="menu">
        <span class="close-button" onclick="closeMenu('shop-menu')">×</span>
        <h2>Магазин</h2>
        <div id="upgrades-container"></div>
    </div>

    <div id="leaderboard-menu" class="menu">
        <span class="close-button" onclick="closeMenu('leaderboard-menu')">×</span>
        <h2>Таблица лидеров</h2>
        <div id="leaderboard-container">В разработке</div>
    </div>

    <div id="boost-menu" class="menu">
        <span class="close-button" onclick="closeMenu('boost-menu')">×</span>
        <h2>Усиления</h2>
        <div id="boosts-container"></div>
    </div>

    <div id="achievements-menu" class="menu">
        <span class="close-button" onclick="closeMenu('achievements-menu')">×</span>
        <h2>Достижения</h2>
        <div id="achievements-container"></div>
    </div>
<script>
    const tg = window.Telegram?.WebApp || {};
    if (tg.expand) tg.expand();
    
    if (tg.colorScheme === 'dark') {
        document.body.classList.add('dark');
    }

    let gameState = {
        balance: 0,
        totalDamage: 0,
        damagePerClick: 1,
        baseDamage: 1,
        dps: 0,
        level: 1,
        experience: 0,
        requiredExperience: 500,
        combo: 1,
        maxCombo: 3,
        activeBoosts: [],
        maxActiveBoosts: 2,
        critChance: 0,
        critMultiplier: 2,
        autoClicker: 0,
        globalMultiplier: 1,
        comboTimeout: null,
        comboTimeoutDuration: 2000,
        clickTimes: [],
        upgrades: {
            knife: { bought: false, cost: 50, damage: 1, type: 'melee' },
            axe: { bought: false, cost: 150, damage: 3, type: 'melee', requires: 'knife' },
            sword: { bought: false, cost: 300, damage: 5, type: 'melee', requires: 'axe' },
            chainsaw: { bought: false, cost: 700, damage: 10, type: 'melee', requires: 'sword' },
            lightsaber: { bought: false, cost: 1500, damage: 20, type: 'melee', requires: 'chainsaw' },
            pistol: { bought: false, cost: 100, damage: 2, type: 'ranged' },
            rifle: { bought: false, cost: 250, damage: 5, type: 'ranged', requires: 'pistol' },
            sniper: { bought: false, cost: 600, damage: 12, type: 'ranged', requires: 'rifle', critChance: 5, critMultiplier: 3 },
            grenadeLauncher: { bought: false, cost: 1200, damage: 25, type: 'ranged', requires: 'sniper', aoe: true },
            plasmaGun: { bought: false, cost: 2500, damage: 50, type: 'ranged', requires: 'grenadeLauncher' },
            infantry: { bought: false, cost: 400, dps: 5, type: 'support' },
            artillery: { bought: false, cost: 1000, dps: 10, type: 'support', requires: 'infantry' }
        },
        boosts: {
            emperor: { 
                name: "За императора!", 
                description: "+2 урона за клик на 1 минуту", 
                cost: 0, 
                cooldown: 24 * 60 * 60 * 1000,
                lastUsed: 0,
                effect: () => { gameState.baseDamage += 2; },
                revert: () => { gameState.baseDamage -= 2; },
                duration: 60000
            },
            mobilization: { 
                name: "Тотальная мобилизация", 
                description: "Удваивает DPS на 30 сек", 
                cost: 0, 
                cooldown: 60 * 60 * 1000,
                lastUsed: 0,
                effect: () => { gameState.dps *= 2; },
                revert: () => { gameState.dps /= 2; },
                duration: 30000
            },
            reconnaissance: {
                name: "Разведка",
                description: "+50% урона на 20 кликов",
                cost: 0,
                cooldown: 45 * 60 * 1000,
                lastUsed: 0,
                effect: () => { gameState.globalMultiplier *= 1.5; },
                revert: () => { gameState.globalMultiplier /= 1.5; },
                clicksLeft: 20
            }
        },
        achievements: {
            comboMaster: { 
                name: "Комбо-мастер", 
                description: "30 кликов за 15 сек", 
                achieved: false, 
                reward: "Комбо не сбрасывается 5 сек",
                condition: (stats) => stats.fastClicks >= 30,
                effect: () => { gameState.comboTimeoutDuration = 5000; }
            },
            veteran: { 
                name: "Ветеран", 
                description: "Достичь 15 уровня", 
                achieved: false, 
                reward: "+1 слот для бустов",
                condition: (stats) => gameState.level >= 15,
                effect: () => { gameState.maxActiveBoosts += 1; }
            },
            beginner: { 
                name: "Новичок", 
                description: "100 кликов", 
                achieved: false, 
                reward: "+1 базовый урон",
                condition: (stats) => stats.totalClicks >= 100,
                effect: () => { gameState.baseDamage += 1; }
            }
        },
        stats: {
            totalClicks: 0,
            fastClicks: 0,
            clicksPerMinute: 0,
            playTime: 0,
            upgradesBought: 0,
            maxBalance: 0,
            critHits: 0,
            comboX2: 0,
            lastClickTime: 0
        }
    };

    function initGame() {
        loadGame();
        calculateDamage();
        startDPS();
        startAutoClicker();
        updateUI();
        setupEventListeners();
    }

    function setupEventListeners() {
        document.getElementById('click-area').addEventListener('click', clickDamage);
        
        document.querySelectorAll('.nav-button').forEach(button => {
            button.addEventListener('click', function() {
                const menuId = this.getAttribute('onclick').match(/'([^']+)'/)[1];
                openMenu(menuId);
            });
        });
        
        document.querySelectorAll('.close-button').forEach(button => {
            button.addEventListener('click', function() {
                const menuId = this.getAttribute('onclick').match(/'([^']+)'/)[1];
                closeMenu(menuId);
            });
        });
    }

    function clickDamage() {
        const now = Date.now();
        gameState.stats.totalClicks++;
        gameState.stats.lastClickTime = now;
        
        gameState.clickTimes.push(now);
        gameState.clickTimes = gameState.clickTimes.filter(time => now - time < 2000);
        
        if (gameState.clickTimes.length >= 10) {
            gameState.combo = Math.min(gameState.maxCombo, gameState.combo + 0.5);
            showCombo();
            if (gameState.combo >= 2) gameState.stats.comboX2++;
        }
        
        if (gameState.comboTimeout) clearTimeout(gameState.comboTimeout);
        gameState.comboTimeout = setTimeout(() => {
            gameState.combo = 1;
            document.getElementById('combo-display').style.opacity = '0';
            document.getElementById('combo-bar').style.display = 'none';
        }, gameState.comboTimeoutDuration);
        
        let damage = gameState.damagePerClick * gameState.combo;
        let isCritical = false;
        
        if (Math.random() * 100 < gameState.critChance) {
            damage *= gameState.critMultiplier;
            isCritical = true;
            gameState.stats.critHits++;
            document.getElementById('click-area').classList.add('critical-hit');
            setTimeout(() => {
                document.getElementById('click-area').classList.remove('critical-hit');
            }, 500);
        }
        
        damage = Math.floor(damage);
        gameState.balance += damage;
        gameState.totalDamage += damage;
        gameState.experience += damage;
        
        checkLevelUp();
        checkAchievements();
        gameState.stats.maxBalance = Math.max(gameState.stats.maxBalance, gameState.balance);
        
        updateUI();
        saveGame();
    }

    function showCombo() {
        const comboDisplay = document.getElementById('combo-display');
        const comboBar = document.getElementById('combo-bar');
        
        comboDisplay.textContent = `x${gameState.combo.toFixed(1)}`;
        comboDisplay.style.opacity = '1';
        comboBar.style.display = 'block';
        comboBar.style.width = `${(gameState.combo / gameState.maxCombo) * 100}%`;
    }

    function calculateDamage() {
        gameState.damagePerClick = gameState.baseDamage;
        gameState.critChance = 0;
        
        for (const [id, upgrade] of Object.entries(gameState.upgrades)) {
            if (upgrade.bought) {
                if (upgrade.type === 'melee') {
                    gameState.damagePerClick += upgrade.damage;
                }
                if (upgrade.type === 'ranged') {
                    gameState.damagePerClick += upgrade.damage;
                    if (upgrade.critChance) gameState.critChance += upgrade.critChance;
                    if (upgrade.critMultiplier) gameState.critMultiplier = Math.max(gameState.critMultiplier, upgrade.critMultiplier);
                }
            }
        }
        
        gameState.damagePerClick = Math.floor(gameState.damagePerClick * gameState.globalMultiplier);
        
        gameState.dps = 0;
        for (const [id, upgrade] of Object.entries(gameState.upgrades)) {
            if (upgrade.bought && upgrade.type === 'support') {
                gameState.dps += upgrade.dps;
            }
        }
        gameState.dps = Math.floor(gameState.dps * gameState.globalMultiplier);
        
        if (gameState.autoClicker > 0) {
            gameState.dps += gameState.baseDamage * gameState.autoClicker;
        }
    }

    function updateUI() {
        document.getElementById('balance').textContent = Math.floor(gameState.balance).toLocaleString();
        document.getElementById('damage-per-click').textContent = Math.floor(gameState.damagePerClick).toLocaleString();
        document.getElementById('total-damage').textContent = Math.floor(gameState.totalDamage).toLocaleString();
        document.getElementById('level').textContent = gameState.level;
        document.getElementById('current-damage').textContent = Math.floor(gameState.experience).toLocaleString();
        document.getElementById('required-damage').textContent = Math.floor(gameState.requiredExperience).toLocaleString();
    }

    function checkLevelUp() {
        while (gameState.experience >= gameState.requiredExperience) {
            gameState.experience -= gameState.requiredExperience;
            gameState.level++;
            gameState.requiredExperience = calculateRequiredExp(gameState.level);
            
            checkAchievements();
        }
    }

    function calculateRequiredExp(lvl) {
        return 500 + (lvl * 200);
    }

    function checkAchievements() {
        for (const [id, achievement] of Object.entries(gameState.achievements)) {
            if (!achievement.achieved && achievement.condition(gameState.stats)) {
                achievement.achieved = true;
                if (achievement.effect) achievement.effect();
                showNotification(`Достижение: ${achievement.name}! ${achievement.reward}`);
                saveGame();
            }
        }
    }

    function showNotification(message) {
        if (window.Telegram && window.Telegram.WebApp) {
            tg.showAlert(message);
        } else {
            alert(message);
        }
    }

    function startDPS() {
        setInterval(() => {
            if (gameState.dps > 0) {
                gameState.balance += gameState.dps;
                gameState.totalDamage += gameState.dps;
                gameState.experience += gameState.dps;
                checkLevelUp();
                updateUI();
                saveGame();
            }
        }, 1000);
    }

    function startAutoClicker() {
        setInterval(() => {
            if (gameState.autoClicker > 0) {
                clickDamage();
            }
        }, 1000);
    }

    function buyUpgrade(id) {
        const upgrade = gameState.upgrades[id];
        if (!upgrade.bought && gameState.balance >= upgrade.cost) {
            if (upgrade.requires && !gameState.upgrades[upgrade.requires].bought) {
                showNotification(`Сначала купите ${getUpgradeName(upgrade.requires)}!`);
                return;
            }
            
            gameState.balance -= upgrade.cost;
            upgrade.bought = true;
            gameState.stats.upgradesBought++;
            
            calculateDamage();
            checkAchievements();
            updateUI();
            renderShop();
            saveGame();
        }
    }

    function getUpgradeName(id) {
        const names = {
            knife: "Нож",
            axe: "Топор",
            sword: "Меч",
            chainsaw: "Бензопила",
            lightsaber: "Лазерный меч",
            pistol: "Пистолет",
            rifle: "Винтовка",
            sniper: "Снайперка",
            grenadeLauncher: "Гранатомёт",
            plasmaGun: "Плазменная пушка",
            infantry: "Поддержка пехоты",
            artillery: "Поддержка артиллерии"
        };
        return names[id] || id;
    }

    function activateBoost(id) {
        const boost = gameState.boosts[id];
        const now = Date.now();
        
        if (now - boost.lastUsed < boost.cooldown) {
            const remaining = Math.ceil((boost.cooldown - (now - boost.lastUsed)) / (60 * 1000));
            showNotification(`Усиление доступно через ${remaining} минут`);
            return;
        }
        
        if (gameState.activeBoosts.length >= gameState.maxActiveBoosts) {
            showNotification(`Можно активировать только ${gameState.maxActiveBoosts} усиления одновременно`);
            return;
        }
        
        boost.lastUsed = now;
        boost.effect();
        
        if (id === 'reconnaissance') {
            gameState.boosts.reconnaissance.clicksLeft = 20;
            const originalOnClick = gameState.boosts.reconnaissance.onClick;
            gameState.boosts.reconnaissance.onClick = (damage) => {
                gameState.boosts.reconnaissance.clicksLeft--;
                if (gameState.boosts.reconnaissance.clicksLeft <= 0) {
                    boost.revert();
                    gameState.activeBoosts = gameState.activeBoosts.filter(b => b.id !== id);
                    gameState.boosts.reconnaissance.onClick = originalOnClick;
                }
                return damage;
            };
        }
        
        const endTime = now + (boost.duration || 0);
        gameState.activeBoosts.push({ id, endTime });
        
        if (boost.duration) {
            setTimeout(() => {
                boost.revert();
                gameState.activeBoosts = gameState.activeBoosts.filter(b => b.id !== id);
                renderBoosts();
                saveGame();
            }, boost.duration);
        }
        
        showNotification(`Активировано: ${boost.name}`);
        renderBoosts();
        saveGame();
    }

    function renderShop() {
        const container = document.getElementById('upgrades-container');
        container.innerHTML = '';
        
        container.innerHTML += '<h3>Ближний бой</h3>';
        for (const [id, upgrade] of Object.entries(gameState.upgrades)) {
            if (upgrade.type === 'melee') {
                const canBuy = !upgrade.bought && gameState.balance >= upgrade.cost && 
                              (!upgrade.requires || gameState.upgrades[upgrade.requires].bought);
                container.innerHTML += `
                    <div class="upgrade ${canBuy ? '' : 'unavailable'}" onclick="buyUpgrade('${id}')">
                        <strong>${getUpgradeName(id)}</strong><br>
                        +${upgrade.damage} урон за клик<br>
                        Цена: ${upgrade.cost}
                        ${upgrade.requires && !gameState.upgrades[upgrade.requires].bought ? `<br><small>Требуется: ${getUpgradeName(upgrade.requires)}</small>` : ''}
                    </div>
                `;
            }
        }
        
        container.innerHTML += '<h3>Дальний бой</h3>';
        for (const [id, upgrade] of Object.entries(gameState.upgrades)) {
            if (upgrade.type === 'ranged') {
                const canBuy = !upgrade.bought && gameState.balance >= upgrade.cost && 
                              (!upgrade.requires || gameState.upgrades[upgrade.requires].bought);
                let special = '';
                if (id === 'sniper') special = `<br>+${upgrade.critChance}% шанс крита (x${upgrade.critMultiplier})`;
                if (id === 'grenadeLauncher') special = '<br>Урон по площади';
                
                container.innerHTML += `
                    <div class="upgrade ${canBuy ? '' : 'unavailable'}" onclick="buyUpgrade('${id}')">
                        <strong>${getUpgradeName(id)}</strong><br>
                        +${upgrade.damage} урон за клик${special}<br>
                        Цена: ${upgrade.cost}
                        ${upgrade.requires && !gameState.upgrades[upgrade.requires].bought ? `<br><small>Требуется: ${getUpgradeName(upgrade.requires)}</small>` : ''}
                    </div>
                `;
            }
        }
        
        container.innerHTML += '<h3>Поддержка</h3>';
        for (const [id, upgrade] of Object.entries(gameState.upgrades)) {
            if (upgrade.type === 'support') {
                const canBuy = !upgrade.bought && gameState.balance >= upgrade.cost && 
                              (!upgrade.requires || gameState.upgrades[upgrade.requires].bought);
                container.innerHTML += `
                    <div class="upgrade ${canBuy ? '' : 'unavailable'}" onclick="buyUpgrade('${id}')">
                        <strong>${getUpgradeName(id)}</strong><br>
                        +${upgrade                         dps} урона в секунду<br>
                        Цена: ${upgrade.cost}
                        ${upgrade.requires && !gameState.upgrades[upgrade.requires].bought ? `<br><small>Требуется: ${getUpgradeName(upgrade.requires)}</small>` : ''}
                    </div>
                `;
            }
        }
    }

    function renderBoosts() {
        const container = document.getElementById('boosts-container');
        container.innerHTML = '';
        
        for (const [id, boost] of Object.entries(gameState.boosts)) {
            const now = Date.now();
            const remainingCooldown = Math.max(0, boost.cooldown - (now - boost.lastUsed));
            const hours = Math.floor(remainingCooldown / (60 * 60 * 1000));
            const minutes = Math.floor((remainingCooldown % (60 * 60 * 1000)) / (60 * 1000));
            
            const isActive = gameState.activeBoosts.some(b => b.id === id);
            const canActivate = remainingCooldown <= 0 && !isActive && gameState.activeBoosts.length < gameState.maxActiveBoosts;
            
            container.innerHTML += `
                <div class="upgrade ${canActivate ? '' : 'unavailable'}" 
                     onclick="${canActivate ? `activateBoost('${id}')` : ''}"
                     style="${!canActivate ? 'opacity: 0.7;' : ''}">
                    <strong>${boost.name}</strong><br>
                    ${boost.description}<br>
                    ${isActive ? 'АКТИВНО' : 
                      remainingCooldown > 0 ? `Доступно через: ${hours}ч ${minutes}м` : 'Готово к использованию'}
                </div>
            `;
        }
    }

    function renderAchievements() {
        const container = document.getElementById('achievements-container');
        container.innerHTML = '';
        
        for (const [id, achievement] of Object.entries(gameState.achievements)) {
            container.innerHTML += `
                <div class="upgrade" style="${achievement.achieved ? 'border: 2px solid gold;' : 'opacity: 0.7;'}">
                    <strong>${achievement.name}</strong><br>
                    ${achievement.description}<br>
                    ${achievement.achieved ? 
                      `<span style="color: green;">Получено: ${achievement.reward}</span>` : 
                      '<span style="color: red;">Не получено</span>'}
                </div>
            `;
        }
    }

    function openMenu(menuId) {
        document.getElementById(menuId).style.display = 'block';
        if (menuId === 'shop-menu') renderShop();
        if (menuId === 'boost-menu') renderBoosts();
        if (menuId === 'achievements-menu') renderAchievements();
    }

    function closeMenu(menuId) {
        document.getElementById(menuId).style.display = 'none';
    }

    function saveGame() {
        localStorage.setItem('warClickerData', JSON.stringify(gameState));
        if (window.Telegram && window.Telegram.WebApp) {
            tg.sendData(JSON.stringify(gameState));
        }
    }

    function loadGame() {
        const savedData = localStorage.getItem('warClickerData');
        if (savedData) {
            const data = JSON.parse(savedData);
            Object.assign(gameState, data);
            calculateDamage();
        }
    }

    // Автосохранение каждые 30 секунд
    setInterval(saveGame, 30000);

    // Инициализация игры при загрузке страницы
    document.addEventListener('DOMContentLoaded', initGame);
</script>
